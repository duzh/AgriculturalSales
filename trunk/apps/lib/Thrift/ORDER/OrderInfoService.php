<?php
namespace ORDER;
/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


interface OrderInfoServiceIf {
  public function createOrder(\ORDER\OrderInfoDTO $orderInfoDTO, \ORDER\BooleanDTO $ifConfirm, \ORDER\BooleanDTO $lazySplit);
  public function confirmOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function confirmMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function cancelMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function cancelOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function payMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function payOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function deliveryOrder(\ORDER\StringDTO $orderSn, \ORDER\ShippingDTO $shippingDTO, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function completeOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO);
  public function getMainOrderBySn(\ORDER\StringDTO $orderSn);
  public function getUnpaidOrdersByUser(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType);
  public function getOrderInfoBySn(\ORDER\StringDTO $orderSn);
  public function getOrdersByBuyer(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize);
  public function getOrdersBySupplier(\ORDER\StringDTO $supplierId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize);
  public function queryOrdersByCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize);
  public function queryOrdersByBuyerAndCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize);
  public function getCountByCondition($conditions);
  public function getCountByBuyerAndCondition($conditions);
  public function getCountByUseridAndOderType(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $userType);
  public function getOrderAddress(\ORDER\StringDTO $orderSn);
  public function getOrderGoods(\ORDER\StringDTO $orderSn, \ORDER\StringDTO $supplierId);
  public function getOrderShippingInfo(\ORDER\StringDTO $orderSn);
  public function getOrderPreferentialInfo(\ORDER\StringDTO $orderSn);
  public function initGoodsStock($goodsStockList);
  public function updateGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType, \ORDER\StringDTO $updateSize);
  public function addGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType, \ORDER\StringDTO $updateSize);
  public function queryGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType);
  public function updateU8Status(\ORDER\StringDTO $orderSn, \ORDER\IntDTO $status);
  public function getAllOrdersByCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize);
  public function getAllOrdersCountByCondition($conditions);
  public function getOrdersByOrderPsn(\ORDER\StringDTO $orderSn);
  public function getOrderLogInfoBySn(\ORDER\StringDTO $orderSn);
  public function getOrdersByOperate($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize);
  public function getOrdersCountByOperate($conditions);
  public function updatePayInfo(\ORDER\StringDTO $orderSn, \ORDER\StringDTO $payId, \ORDER\StringDTO $payWay, \ORDER\StringDTO $payUrl, \ORDER\OrderOperatorDTO $orderOperatorDTO);
}

class OrderInfoServiceClient implements \ORDER\OrderInfoServiceIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function createOrder(\ORDER\OrderInfoDTO $orderInfoDTO, \ORDER\BooleanDTO $ifConfirm, \ORDER\BooleanDTO $lazySplit)
  {
    $this->send_createOrder($orderInfoDTO, $ifConfirm, $lazySplit);
    return $this->recv_createOrder();
  }

  public function send_createOrder(\ORDER\OrderInfoDTO $orderInfoDTO, \ORDER\BooleanDTO $ifConfirm, \ORDER\BooleanDTO $lazySplit)
  {
    $args = new \ORDER\OrderInfoService_createOrder_args();
    $args->orderInfoDTO = $orderInfoDTO;
    $args->ifConfirm = $ifConfirm;
    $args->lazySplit = $lazySplit;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'createOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('createOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_createOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_createOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_createOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("createOrder failed: unknown result");
  }

  public function confirmOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_confirmOrder($orderSn, $orderOperatorDTO);
    return $this->recv_confirmOrder();
  }

  public function send_confirmOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_confirmOrder_args();
    $args->orderSn = $orderSn;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'confirmOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('confirmOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_confirmOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_confirmOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_confirmOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("confirmOrder failed: unknown result");
  }

  public function confirmMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_confirmMainOrder($orderSn, $orderOperatorDTO);
    return $this->recv_confirmMainOrder();
  }

  public function send_confirmMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_confirmMainOrder_args();
    $args->orderSn = $orderSn;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'confirmMainOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('confirmMainOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_confirmMainOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_confirmMainOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_confirmMainOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("confirmMainOrder failed: unknown result");
  }

  public function cancelMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_cancelMainOrder($orderSn, $orderOperatorDTO);
    return $this->recv_cancelMainOrder();
  }

  public function send_cancelMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_cancelMainOrder_args();
    $args->orderSn = $orderSn;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'cancelMainOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('cancelMainOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_cancelMainOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_cancelMainOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_cancelMainOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("cancelMainOrder failed: unknown result");
  }

  public function cancelOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_cancelOrder($orderSn, $orderOperatorDTO);
    return $this->recv_cancelOrder();
  }

  public function send_cancelOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_cancelOrder_args();
    $args->orderSn = $orderSn;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'cancelOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('cancelOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_cancelOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_cancelOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_cancelOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("cancelOrder failed: unknown result");
  }

  public function payMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_payMainOrder($orderSn, $orderOperatorDTO);
    return $this->recv_payMainOrder();
  }

  public function send_payMainOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_payMainOrder_args();
    $args->orderSn = $orderSn;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'payMainOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('payMainOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_payMainOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_payMainOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_payMainOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("payMainOrder failed: unknown result");
  }

  public function payOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_payOrder($orderSn, $orderOperatorDTO);
    return $this->recv_payOrder();
  }

  public function send_payOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_payOrder_args();
    $args->orderSn = $orderSn;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'payOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('payOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_payOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_payOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_payOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("payOrder failed: unknown result");
  }

  public function deliveryOrder(\ORDER\StringDTO $orderSn, \ORDER\ShippingDTO $shippingDTO, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_deliveryOrder($orderSn, $shippingDTO, $orderOperatorDTO);
    return $this->recv_deliveryOrder();
  }

  public function send_deliveryOrder(\ORDER\StringDTO $orderSn, \ORDER\ShippingDTO $shippingDTO, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_deliveryOrder_args();
    $args->orderSn = $orderSn;
    $args->shippingDTO = $shippingDTO;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deliveryOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deliveryOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deliveryOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_deliveryOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_deliveryOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("deliveryOrder failed: unknown result");
  }

  public function completeOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_completeOrder($orderSn, $orderOperatorDTO);
    return $this->recv_completeOrder();
  }

  public function send_completeOrder(\ORDER\StringDTO $orderSn, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_completeOrder_args();
    $args->orderSn = $orderSn;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'completeOrder', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('completeOrder', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_completeOrder()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_completeOrder_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_completeOrder_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("completeOrder failed: unknown result");
  }

  public function getMainOrderBySn(\ORDER\StringDTO $orderSn)
  {
    $this->send_getMainOrderBySn($orderSn);
    return $this->recv_getMainOrderBySn();
  }

  public function send_getMainOrderBySn(\ORDER\StringDTO $orderSn)
  {
    $args = new \ORDER\OrderInfoService_getMainOrderBySn_args();
    $args->orderSn = $orderSn;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getMainOrderBySn', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getMainOrderBySn', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getMainOrderBySn()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getMainOrderBySn_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getMainOrderBySn_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getMainOrderBySn failed: unknown result");
  }

  public function getUnpaidOrdersByUser(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType)
  {
    $this->send_getUnpaidOrdersByUser($buyerId, $orderType);
    return $this->recv_getUnpaidOrdersByUser();
  }

  public function send_getUnpaidOrdersByUser(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType)
  {
    $args = new \ORDER\OrderInfoService_getUnpaidOrdersByUser_args();
    $args->buyerId = $buyerId;
    $args->orderType = $orderType;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getUnpaidOrdersByUser', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getUnpaidOrdersByUser', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getUnpaidOrdersByUser()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getUnpaidOrdersByUser_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getUnpaidOrdersByUser_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getUnpaidOrdersByUser failed: unknown result");
  }

  public function getOrderInfoBySn(\ORDER\StringDTO $orderSn)
  {
    $this->send_getOrderInfoBySn($orderSn);
    return $this->recv_getOrderInfoBySn();
  }

  public function send_getOrderInfoBySn(\ORDER\StringDTO $orderSn)
  {
    $args = new \ORDER\OrderInfoService_getOrderInfoBySn_args();
    $args->orderSn = $orderSn;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrderInfoBySn', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrderInfoBySn', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrderInfoBySn()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrderInfoBySn_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrderInfoBySn_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrderInfoBySn failed: unknown result");
  }

  public function getOrdersByBuyer(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $this->send_getOrdersByBuyer($buyerId, $orderType, $currentPage, $pageSize);
    return $this->recv_getOrdersByBuyer();
  }

  public function send_getOrdersByBuyer(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $args = new \ORDER\OrderInfoService_getOrdersByBuyer_args();
    $args->buyerId = $buyerId;
    $args->orderType = $orderType;
    $args->currentPage = $currentPage;
    $args->pageSize = $pageSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrdersByBuyer', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrdersByBuyer', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrdersByBuyer()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrdersByBuyer_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrdersByBuyer_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrdersByBuyer failed: unknown result");
  }

  public function getOrdersBySupplier(\ORDER\StringDTO $supplierId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $this->send_getOrdersBySupplier($supplierId, $orderType, $currentPage, $pageSize);
    return $this->recv_getOrdersBySupplier();
  }

  public function send_getOrdersBySupplier(\ORDER\StringDTO $supplierId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $args = new \ORDER\OrderInfoService_getOrdersBySupplier_args();
    $args->supplierId = $supplierId;
    $args->orderType = $orderType;
    $args->currentPage = $currentPage;
    $args->pageSize = $pageSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrdersBySupplier', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrdersBySupplier', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrdersBySupplier()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrdersBySupplier_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrdersBySupplier_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrdersBySupplier failed: unknown result");
  }

  public function queryOrdersByCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $this->send_queryOrdersByCondition($conditions, $currentPage, $pageSize);
    return $this->recv_queryOrdersByCondition();
  }

  public function send_queryOrdersByCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $args = new \ORDER\OrderInfoService_queryOrdersByCondition_args();
    $args->conditions = $conditions;
    $args->currentPage = $currentPage;
    $args->pageSize = $pageSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'queryOrdersByCondition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('queryOrdersByCondition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_queryOrdersByCondition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_queryOrdersByCondition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_queryOrdersByCondition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("queryOrdersByCondition failed: unknown result");
  }

  public function queryOrdersByBuyerAndCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $this->send_queryOrdersByBuyerAndCondition($conditions, $currentPage, $pageSize);
    return $this->recv_queryOrdersByBuyerAndCondition();
  }

  public function send_queryOrdersByBuyerAndCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $args = new \ORDER\OrderInfoService_queryOrdersByBuyerAndCondition_args();
    $args->conditions = $conditions;
    $args->currentPage = $currentPage;
    $args->pageSize = $pageSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'queryOrdersByBuyerAndCondition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('queryOrdersByBuyerAndCondition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_queryOrdersByBuyerAndCondition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_queryOrdersByBuyerAndCondition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_queryOrdersByBuyerAndCondition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("queryOrdersByBuyerAndCondition failed: unknown result");
  }

  public function getCountByCondition($conditions)
  {
    $this->send_getCountByCondition($conditions);
    return $this->recv_getCountByCondition();
  }

  public function send_getCountByCondition($conditions)
  {
    $args = new \ORDER\OrderInfoService_getCountByCondition_args();
    $args->conditions = $conditions;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getCountByCondition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getCountByCondition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getCountByCondition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getCountByCondition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getCountByCondition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getCountByCondition failed: unknown result");
  }

  public function getCountByBuyerAndCondition($conditions)
  {
    $this->send_getCountByBuyerAndCondition($conditions);
    return $this->recv_getCountByBuyerAndCondition();
  }

  public function send_getCountByBuyerAndCondition($conditions)
  {
    $args = new \ORDER\OrderInfoService_getCountByBuyerAndCondition_args();
    $args->conditions = $conditions;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getCountByBuyerAndCondition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getCountByBuyerAndCondition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getCountByBuyerAndCondition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getCountByBuyerAndCondition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getCountByBuyerAndCondition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getCountByBuyerAndCondition failed: unknown result");
  }

  public function getCountByUseridAndOderType(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $userType)
  {
    $this->send_getCountByUseridAndOderType($buyerId, $orderType, $userType);
    return $this->recv_getCountByUseridAndOderType();
  }

  public function send_getCountByUseridAndOderType(\ORDER\StringDTO $buyerId, \ORDER\IntDTO $orderType, \ORDER\IntDTO $userType)
  {
    $args = new \ORDER\OrderInfoService_getCountByUseridAndOderType_args();
    $args->buyerId = $buyerId;
    $args->orderType = $orderType;
    $args->userType = $userType;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getCountByUseridAndOderType', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getCountByUseridAndOderType', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getCountByUseridAndOderType()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getCountByUseridAndOderType_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getCountByUseridAndOderType_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getCountByUseridAndOderType failed: unknown result");
  }

  public function getOrderAddress(\ORDER\StringDTO $orderSn)
  {
    $this->send_getOrderAddress($orderSn);
    return $this->recv_getOrderAddress();
  }

  public function send_getOrderAddress(\ORDER\StringDTO $orderSn)
  {
    $args = new \ORDER\OrderInfoService_getOrderAddress_args();
    $args->orderSn = $orderSn;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrderAddress', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrderAddress', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrderAddress()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrderAddress_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrderAddress_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrderAddress failed: unknown result");
  }

  public function getOrderGoods(\ORDER\StringDTO $orderSn, \ORDER\StringDTO $supplierId)
  {
    $this->send_getOrderGoods($orderSn, $supplierId);
    return $this->recv_getOrderGoods();
  }

  public function send_getOrderGoods(\ORDER\StringDTO $orderSn, \ORDER\StringDTO $supplierId)
  {
    $args = new \ORDER\OrderInfoService_getOrderGoods_args();
    $args->orderSn = $orderSn;
    $args->supplierId = $supplierId;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrderGoods', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrderGoods', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrderGoods()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrderGoods_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrderGoods_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrderGoods failed: unknown result");
  }

  public function getOrderShippingInfo(\ORDER\StringDTO $orderSn)
  {
    $this->send_getOrderShippingInfo($orderSn);
    return $this->recv_getOrderShippingInfo();
  }

  public function send_getOrderShippingInfo(\ORDER\StringDTO $orderSn)
  {
    $args = new \ORDER\OrderInfoService_getOrderShippingInfo_args();
    $args->orderSn = $orderSn;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrderShippingInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrderShippingInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrderShippingInfo()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrderShippingInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrderShippingInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrderShippingInfo failed: unknown result");
  }

  public function getOrderPreferentialInfo(\ORDER\StringDTO $orderSn)
  {
    $this->send_getOrderPreferentialInfo($orderSn);
    return $this->recv_getOrderPreferentialInfo();
  }

  public function send_getOrderPreferentialInfo(\ORDER\StringDTO $orderSn)
  {
    $args = new \ORDER\OrderInfoService_getOrderPreferentialInfo_args();
    $args->orderSn = $orderSn;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrderPreferentialInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrderPreferentialInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrderPreferentialInfo()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrderPreferentialInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrderPreferentialInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrderPreferentialInfo failed: unknown result");
  }

  public function initGoodsStock($goodsStockList)
  {
    $this->send_initGoodsStock($goodsStockList);
    return $this->recv_initGoodsStock();
  }

  public function send_initGoodsStock($goodsStockList)
  {
    $args = new \ORDER\OrderInfoService_initGoodsStock_args();
    $args->goodsStockList = $goodsStockList;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'initGoodsStock', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('initGoodsStock', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_initGoodsStock()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_initGoodsStock_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_initGoodsStock_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("initGoodsStock failed: unknown result");
  }

  public function updateGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType, \ORDER\StringDTO $updateSize)
  {
    $this->send_updateGoodsStock($goodsId, $orderType, $updateSize);
    return $this->recv_updateGoodsStock();
  }

  public function send_updateGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType, \ORDER\StringDTO $updateSize)
  {
    $args = new \ORDER\OrderInfoService_updateGoodsStock_args();
    $args->goodsId = $goodsId;
    $args->orderType = $orderType;
    $args->updateSize = $updateSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'updateGoodsStock', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('updateGoodsStock', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_updateGoodsStock()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_updateGoodsStock_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_updateGoodsStock_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("updateGoodsStock failed: unknown result");
  }

  public function addGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType, \ORDER\StringDTO $updateSize)
  {
    $this->send_addGoodsStock($goodsId, $orderType, $updateSize);
    return $this->recv_addGoodsStock();
  }

  public function send_addGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType, \ORDER\StringDTO $updateSize)
  {
    $args = new \ORDER\OrderInfoService_addGoodsStock_args();
    $args->goodsId = $goodsId;
    $args->orderType = $orderType;
    $args->updateSize = $updateSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'addGoodsStock', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('addGoodsStock', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_addGoodsStock()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_addGoodsStock_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_addGoodsStock_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("addGoodsStock failed: unknown result");
  }

  public function queryGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType)
  {
    $this->send_queryGoodsStock($goodsId, $orderType);
    return $this->recv_queryGoodsStock();
  }

  public function send_queryGoodsStock(\ORDER\StringDTO $goodsId, \ORDER\StringDTO $orderType)
  {
    $args = new \ORDER\OrderInfoService_queryGoodsStock_args();
    $args->goodsId = $goodsId;
    $args->orderType = $orderType;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'queryGoodsStock', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('queryGoodsStock', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_queryGoodsStock()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_queryGoodsStock_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_queryGoodsStock_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("queryGoodsStock failed: unknown result");
  }

  public function updateU8Status(\ORDER\StringDTO $orderSn, \ORDER\IntDTO $status)
  {
    $this->send_updateU8Status($orderSn, $status);
    return $this->recv_updateU8Status();
  }

  public function send_updateU8Status(\ORDER\StringDTO $orderSn, \ORDER\IntDTO $status)
  {
    $args = new \ORDER\OrderInfoService_updateU8Status_args();
    $args->orderSn = $orderSn;
    $args->status = $status;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'updateU8Status', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('updateU8Status', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_updateU8Status()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_updateU8Status_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_updateU8Status_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("updateU8Status failed: unknown result");
  }

  public function getAllOrdersByCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $this->send_getAllOrdersByCondition($conditions, $currentPage, $pageSize);
    return $this->recv_getAllOrdersByCondition();
  }

  public function send_getAllOrdersByCondition($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $args = new \ORDER\OrderInfoService_getAllOrdersByCondition_args();
    $args->conditions = $conditions;
    $args->currentPage = $currentPage;
    $args->pageSize = $pageSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getAllOrdersByCondition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getAllOrdersByCondition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getAllOrdersByCondition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getAllOrdersByCondition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getAllOrdersByCondition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getAllOrdersByCondition failed: unknown result");
  }

  public function getAllOrdersCountByCondition($conditions)
  {
    $this->send_getAllOrdersCountByCondition($conditions);
    return $this->recv_getAllOrdersCountByCondition();
  }

  public function send_getAllOrdersCountByCondition($conditions)
  {
    $args = new \ORDER\OrderInfoService_getAllOrdersCountByCondition_args();
    $args->conditions = $conditions;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getAllOrdersCountByCondition', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getAllOrdersCountByCondition', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getAllOrdersCountByCondition()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getAllOrdersCountByCondition_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getAllOrdersCountByCondition_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getAllOrdersCountByCondition failed: unknown result");
  }

  public function getOrdersByOrderPsn(\ORDER\StringDTO $orderSn)
  {
    $this->send_getOrdersByOrderPsn($orderSn);
    return $this->recv_getOrdersByOrderPsn();
  }

  public function send_getOrdersByOrderPsn(\ORDER\StringDTO $orderSn)
  {
    $args = new \ORDER\OrderInfoService_getOrdersByOrderPsn_args();
    $args->orderSn = $orderSn;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrdersByOrderPsn', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrdersByOrderPsn', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrdersByOrderPsn()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrdersByOrderPsn_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrdersByOrderPsn_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrdersByOrderPsn failed: unknown result");
  }

  public function getOrderLogInfoBySn(\ORDER\StringDTO $orderSn)
  {
    $this->send_getOrderLogInfoBySn($orderSn);
    return $this->recv_getOrderLogInfoBySn();
  }

  public function send_getOrderLogInfoBySn(\ORDER\StringDTO $orderSn)
  {
    $args = new \ORDER\OrderInfoService_getOrderLogInfoBySn_args();
    $args->orderSn = $orderSn;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrderLogInfoBySn', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrderLogInfoBySn', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrderLogInfoBySn()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrderLogInfoBySn_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrderLogInfoBySn_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrderLogInfoBySn failed: unknown result");
  }

  public function getOrdersByOperate($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $this->send_getOrdersByOperate($conditions, $currentPage, $pageSize);
    return $this->recv_getOrdersByOperate();
  }

  public function send_getOrdersByOperate($conditions, \ORDER\IntDTO $currentPage, \ORDER\IntDTO $pageSize)
  {
    $args = new \ORDER\OrderInfoService_getOrdersByOperate_args();
    $args->conditions = $conditions;
    $args->currentPage = $currentPage;
    $args->pageSize = $pageSize;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrdersByOperate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrdersByOperate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrdersByOperate()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrdersByOperate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrdersByOperate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrdersByOperate failed: unknown result");
  }

  public function getOrdersCountByOperate($conditions)
  {
    $this->send_getOrdersCountByOperate($conditions);
    return $this->recv_getOrdersCountByOperate();
  }

  public function send_getOrdersCountByOperate($conditions)
  {
    $args = new \ORDER\OrderInfoService_getOrdersCountByOperate_args();
    $args->conditions = $conditions;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getOrdersCountByOperate', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getOrdersCountByOperate', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getOrdersCountByOperate()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_getOrdersCountByOperate_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_getOrdersCountByOperate_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("getOrdersCountByOperate failed: unknown result");
  }

  public function updatePayInfo(\ORDER\StringDTO $orderSn, \ORDER\StringDTO $payId, \ORDER\StringDTO $payWay, \ORDER\StringDTO $payUrl, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $this->send_updatePayInfo($orderSn, $payId, $payWay, $payUrl, $orderOperatorDTO);
    return $this->recv_updatePayInfo();
  }

  public function send_updatePayInfo(\ORDER\StringDTO $orderSn, \ORDER\StringDTO $payId, \ORDER\StringDTO $payWay, \ORDER\StringDTO $payUrl, \ORDER\OrderOperatorDTO $orderOperatorDTO)
  {
    $args = new \ORDER\OrderInfoService_updatePayInfo_args();
    $args->orderSn = $orderSn;
    $args->payId = $payId;
    $args->payWay = $payWay;
    $args->payUrl = $payUrl;
    $args->orderOperatorDTO = $orderOperatorDTO;
    $bin_accel = ($this->output_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'updatePayInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('updatePayInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_updatePayInfo()
  {
    $bin_accel = ($this->input_ instanceof TBinaryProtocolAccelerated) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, '\ORDER\OrderInfoService_updatePayInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new \ORDER\OrderInfoService_updatePayInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    throw new \Exception("updatePayInfo failed: unknown result");
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class OrderInfoService_createOrder_args {
  static $_TSPEC;

  public $orderInfoDTO = null;
  public $ifConfirm = null;
  public $lazySplit = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderInfoDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderInfoDTO',
          ),
        2 => array(
          'var' => 'ifConfirm',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        3 => array(
          'var' => 'lazySplit',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderInfoDTO'])) {
        $this->orderInfoDTO = $vals['orderInfoDTO'];
      }
      if (isset($vals['ifConfirm'])) {
        $this->ifConfirm = $vals['ifConfirm'];
      }
      if (isset($vals['lazySplit'])) {
        $this->lazySplit = $vals['lazySplit'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_createOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderInfoDTO = new \ORDER\OrderInfoDTO();
            $xfer += $this->orderInfoDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ifConfirm = new \ORDER\BooleanDTO();
            $xfer += $this->ifConfirm->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->lazySplit = new \ORDER\BooleanDTO();
            $xfer += $this->lazySplit->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_createOrder_args');
    if ($this->orderInfoDTO !== null) {
      if (!is_object($this->orderInfoDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderInfoDTO', TType::STRUCT, 1);
      $xfer += $this->orderInfoDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ifConfirm !== null) {
      if (!is_object($this->ifConfirm)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ifConfirm', TType::STRUCT, 2);
      $xfer += $this->ifConfirm->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lazySplit !== null) {
      if (!is_object($this->lazySplit)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('lazySplit', TType::STRUCT, 3);
      $xfer += $this->lazySplit->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_createOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_createOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_createOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_confirmOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_confirmOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_confirmOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 2);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_confirmOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_confirmOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_confirmOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_confirmMainOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_confirmMainOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_confirmMainOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 2);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_confirmMainOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_confirmMainOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_confirmMainOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_cancelMainOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_cancelMainOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_cancelMainOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 2);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_cancelMainOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_cancelMainOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_cancelMainOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_cancelOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_cancelOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_cancelOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 2);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_cancelOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_cancelOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_cancelOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_payMainOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_payMainOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_payMainOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 2);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_payMainOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_payMainOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_payMainOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_payOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_payOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_payOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 2);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_payOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_payOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_payOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_deliveryOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $shippingDTO = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'shippingDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\ShippingDTO',
          ),
        3 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['shippingDTO'])) {
        $this->shippingDTO = $vals['shippingDTO'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_deliveryOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->shippingDTO = new \ORDER\ShippingDTO();
            $xfer += $this->shippingDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_deliveryOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->shippingDTO !== null) {
      if (!is_object($this->shippingDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('shippingDTO', TType::STRUCT, 2);
      $xfer += $this->shippingDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 3);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_deliveryOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_deliveryOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_deliveryOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_completeOrder_args {
  static $_TSPEC;

  public $orderSn = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_completeOrder_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_completeOrder_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 2);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_completeOrder_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_completeOrder_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_completeOrder_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getMainOrderBySn_args {
  static $_TSPEC;

  public $orderSn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getMainOrderBySn_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getMainOrderBySn_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getMainOrderBySn_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderInfoDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getMainOrderBySn_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\OrderInfoDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getMainOrderBySn_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getUnpaidOrdersByUser_args {
  static $_TSPEC;

  public $buyerId = null;
  public $orderType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'buyerId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['buyerId'])) {
        $this->buyerId = $vals['buyerId'];
      }
      if (isset($vals['orderType'])) {
        $this->orderType = $vals['orderType'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getUnpaidOrdersByUser_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->buyerId = new \ORDER\StringDTO();
            $xfer += $this->buyerId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderType = new \ORDER\IntDTO();
            $xfer += $this->orderType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getUnpaidOrdersByUser_args');
    if ($this->buyerId !== null) {
      if (!is_object($this->buyerId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('buyerId', TType::STRUCT, 1);
      $xfer += $this->buyerId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderType !== null) {
      if (!is_object($this->orderType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderType', TType::STRUCT, 2);
      $xfer += $this->orderType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getUnpaidOrdersByUser_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getUnpaidOrdersByUser_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size21 = 0;
            $_etype24 = 0;
            $xfer += $input->readListBegin($_etype24, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $elem26 = null;
              $elem26 = new \ORDER\OrderInfoDTO();
              $xfer += $elem26->read($input);
              $this->success []= $elem26;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getUnpaidOrdersByUser_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter27)
          {
            $xfer += $iter27->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderInfoBySn_args {
  static $_TSPEC;

  public $orderSn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderInfoBySn_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderInfoBySn_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderInfoBySn_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderSubDetailInfoDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderInfoBySn_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\OrderSubDetailInfoDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderInfoBySn_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersByBuyer_args {
  static $_TSPEC;

  public $buyerId = null;
  public $orderType = null;
  public $currentPage = null;
  public $pageSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'buyerId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        3 => array(
          'var' => 'currentPage',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        4 => array(
          'var' => 'pageSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['buyerId'])) {
        $this->buyerId = $vals['buyerId'];
      }
      if (isset($vals['orderType'])) {
        $this->orderType = $vals['orderType'];
      }
      if (isset($vals['currentPage'])) {
        $this->currentPage = $vals['currentPage'];
      }
      if (isset($vals['pageSize'])) {
        $this->pageSize = $vals['pageSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersByBuyer_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->buyerId = new \ORDER\StringDTO();
            $xfer += $this->buyerId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderType = new \ORDER\IntDTO();
            $xfer += $this->orderType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->currentPage = new \ORDER\IntDTO();
            $xfer += $this->currentPage->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->pageSize = new \ORDER\IntDTO();
            $xfer += $this->pageSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersByBuyer_args');
    if ($this->buyerId !== null) {
      if (!is_object($this->buyerId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('buyerId', TType::STRUCT, 1);
      $xfer += $this->buyerId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderType !== null) {
      if (!is_object($this->orderType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderType', TType::STRUCT, 2);
      $xfer += $this->orderType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentPage !== null) {
      if (!is_object($this->currentPage)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('currentPage', TType::STRUCT, 3);
      $xfer += $this->currentPage->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pageSize !== null) {
      if (!is_object($this->pageSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pageSize', TType::STRUCT, 4);
      $xfer += $this->pageSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersByBuyer_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderSubDetailInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersByBuyer_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size28 = 0;
            $_etype31 = 0;
            $xfer += $input->readListBegin($_etype31, $_size28);
            for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
            {
              $elem33 = null;
              $elem33 = new \ORDER\OrderSubDetailInfoDTO();
              $xfer += $elem33->read($input);
              $this->success []= $elem33;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersByBuyer_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter34)
          {
            $xfer += $iter34->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersBySupplier_args {
  static $_TSPEC;

  public $supplierId = null;
  public $orderType = null;
  public $currentPage = null;
  public $pageSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'supplierId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        3 => array(
          'var' => 'currentPage',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        4 => array(
          'var' => 'pageSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['supplierId'])) {
        $this->supplierId = $vals['supplierId'];
      }
      if (isset($vals['orderType'])) {
        $this->orderType = $vals['orderType'];
      }
      if (isset($vals['currentPage'])) {
        $this->currentPage = $vals['currentPage'];
      }
      if (isset($vals['pageSize'])) {
        $this->pageSize = $vals['pageSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersBySupplier_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->supplierId = new \ORDER\StringDTO();
            $xfer += $this->supplierId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderType = new \ORDER\IntDTO();
            $xfer += $this->orderType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->currentPage = new \ORDER\IntDTO();
            $xfer += $this->currentPage->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->pageSize = new \ORDER\IntDTO();
            $xfer += $this->pageSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersBySupplier_args');
    if ($this->supplierId !== null) {
      if (!is_object($this->supplierId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('supplierId', TType::STRUCT, 1);
      $xfer += $this->supplierId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderType !== null) {
      if (!is_object($this->orderType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderType', TType::STRUCT, 2);
      $xfer += $this->orderType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentPage !== null) {
      if (!is_object($this->currentPage)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('currentPage', TType::STRUCT, 3);
      $xfer += $this->currentPage->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pageSize !== null) {
      if (!is_object($this->pageSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pageSize', TType::STRUCT, 4);
      $xfer += $this->pageSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersBySupplier_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderSubDetailInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersBySupplier_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size35 = 0;
            $_etype38 = 0;
            $xfer += $input->readListBegin($_etype38, $_size35);
            for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
            {
              $elem40 = null;
              $elem40 = new \ORDER\OrderSubDetailInfoDTO();
              $xfer += $elem40->read($input);
              $this->success []= $elem40;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersBySupplier_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter41)
          {
            $xfer += $iter41->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_queryOrdersByCondition_args {
  static $_TSPEC;

  public $conditions = null;
  public $currentPage = null;
  public $pageSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'currentPage',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        3 => array(
          'var' => 'pageSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
      if (isset($vals['currentPage'])) {
        $this->currentPage = $vals['currentPage'];
      }
      if (isset($vals['pageSize'])) {
        $this->pageSize = $vals['pageSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_queryOrdersByCondition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size42 = 0;
            $_ktype43 = 0;
            $_vtype44 = 0;
            $xfer += $input->readMapBegin($_ktype43, $_vtype44, $_size42);
            for ($_i46 = 0; $_i46 < $_size42; ++$_i46)
            {
              $key47 = '';
              $val48 = '';
              $xfer += $input->readString($key47);
              $xfer += $input->readString($val48);
              $this->conditions[$key47] = $val48;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->currentPage = new \ORDER\IntDTO();
            $xfer += $this->currentPage->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->pageSize = new \ORDER\IntDTO();
            $xfer += $this->pageSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_queryOrdersByCondition_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter49 => $viter50)
          {
            $xfer += $output->writeString($kiter49);
            $xfer += $output->writeString($viter50);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentPage !== null) {
      if (!is_object($this->currentPage)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('currentPage', TType::STRUCT, 2);
      $xfer += $this->currentPage->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pageSize !== null) {
      if (!is_object($this->pageSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pageSize', TType::STRUCT, 3);
      $xfer += $this->pageSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_queryOrdersByCondition_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderSubDetailInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_queryOrdersByCondition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size51 = 0;
            $_etype54 = 0;
            $xfer += $input->readListBegin($_etype54, $_size51);
            for ($_i55 = 0; $_i55 < $_size51; ++$_i55)
            {
              $elem56 = null;
              $elem56 = new \ORDER\OrderSubDetailInfoDTO();
              $xfer += $elem56->read($input);
              $this->success []= $elem56;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_queryOrdersByCondition_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter57)
          {
            $xfer += $iter57->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_queryOrdersByBuyerAndCondition_args {
  static $_TSPEC;

  public $conditions = null;
  public $currentPage = null;
  public $pageSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'currentPage',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        3 => array(
          'var' => 'pageSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
      if (isset($vals['currentPage'])) {
        $this->currentPage = $vals['currentPage'];
      }
      if (isset($vals['pageSize'])) {
        $this->pageSize = $vals['pageSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_queryOrdersByBuyerAndCondition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size58 = 0;
            $_ktype59 = 0;
            $_vtype60 = 0;
            $xfer += $input->readMapBegin($_ktype59, $_vtype60, $_size58);
            for ($_i62 = 0; $_i62 < $_size58; ++$_i62)
            {
              $key63 = '';
              $val64 = '';
              $xfer += $input->readString($key63);
              $xfer += $input->readString($val64);
              $this->conditions[$key63] = $val64;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->currentPage = new \ORDER\IntDTO();
            $xfer += $this->currentPage->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->pageSize = new \ORDER\IntDTO();
            $xfer += $this->pageSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_queryOrdersByBuyerAndCondition_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter65 => $viter66)
          {
            $xfer += $output->writeString($kiter65);
            $xfer += $output->writeString($viter66);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentPage !== null) {
      if (!is_object($this->currentPage)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('currentPage', TType::STRUCT, 2);
      $xfer += $this->currentPage->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pageSize !== null) {
      if (!is_object($this->pageSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pageSize', TType::STRUCT, 3);
      $xfer += $this->pageSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_queryOrdersByBuyerAndCondition_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderSubDetailInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_queryOrdersByBuyerAndCondition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size67 = 0;
            $_etype70 = 0;
            $xfer += $input->readListBegin($_etype70, $_size67);
            for ($_i71 = 0; $_i71 < $_size67; ++$_i71)
            {
              $elem72 = null;
              $elem72 = new \ORDER\OrderSubDetailInfoDTO();
              $xfer += $elem72->read($input);
              $this->success []= $elem72;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_queryOrdersByBuyerAndCondition_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter73)
          {
            $xfer += $iter73->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getCountByCondition_args {
  static $_TSPEC;

  public $conditions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getCountByCondition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size74 = 0;
            $_ktype75 = 0;
            $_vtype76 = 0;
            $xfer += $input->readMapBegin($_ktype75, $_vtype76, $_size74);
            for ($_i78 = 0; $_i78 < $_size74; ++$_i78)
            {
              $key79 = '';
              $val80 = '';
              $xfer += $input->readString($key79);
              $xfer += $input->readString($val80);
              $this->conditions[$key79] = $val80;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getCountByCondition_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter81 => $viter82)
          {
            $xfer += $output->writeString($kiter81);
            $xfer += $output->writeString($viter82);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getCountByCondition_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getCountByCondition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\IntDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getCountByCondition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getCountByBuyerAndCondition_args {
  static $_TSPEC;

  public $conditions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getCountByBuyerAndCondition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size83 = 0;
            $_ktype84 = 0;
            $_vtype85 = 0;
            $xfer += $input->readMapBegin($_ktype84, $_vtype85, $_size83);
            for ($_i87 = 0; $_i87 < $_size83; ++$_i87)
            {
              $key88 = '';
              $val89 = '';
              $xfer += $input->readString($key88);
              $xfer += $input->readString($val89);
              $this->conditions[$key88] = $val89;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getCountByBuyerAndCondition_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter90 => $viter91)
          {
            $xfer += $output->writeString($kiter90);
            $xfer += $output->writeString($viter91);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getCountByBuyerAndCondition_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getCountByBuyerAndCondition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\IntDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getCountByBuyerAndCondition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getCountByUseridAndOderType_args {
  static $_TSPEC;

  public $buyerId = null;
  public $orderType = null;
  public $userType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'buyerId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        3 => array(
          'var' => 'userType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['buyerId'])) {
        $this->buyerId = $vals['buyerId'];
      }
      if (isset($vals['orderType'])) {
        $this->orderType = $vals['orderType'];
      }
      if (isset($vals['userType'])) {
        $this->userType = $vals['userType'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getCountByUseridAndOderType_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->buyerId = new \ORDER\StringDTO();
            $xfer += $this->buyerId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderType = new \ORDER\IntDTO();
            $xfer += $this->orderType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->userType = new \ORDER\IntDTO();
            $xfer += $this->userType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getCountByUseridAndOderType_args');
    if ($this->buyerId !== null) {
      if (!is_object($this->buyerId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('buyerId', TType::STRUCT, 1);
      $xfer += $this->buyerId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderType !== null) {
      if (!is_object($this->orderType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderType', TType::STRUCT, 2);
      $xfer += $this->orderType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userType !== null) {
      if (!is_object($this->userType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userType', TType::STRUCT, 3);
      $xfer += $this->userType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getCountByUseridAndOderType_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getCountByUseridAndOderType_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\IntDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getCountByUseridAndOderType_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderAddress_args {
  static $_TSPEC;

  public $orderSn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderAddress_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderAddress_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderAddress_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderAddressInfoDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderAddress_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\OrderAddressInfoDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderAddress_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderGoods_args {
  static $_TSPEC;

  public $orderSn = null;
  public $supplierId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'supplierId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['supplierId'])) {
        $this->supplierId = $vals['supplierId'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderGoods_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->supplierId = new \ORDER\StringDTO();
            $xfer += $this->supplierId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderGoods_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->supplierId !== null) {
      if (!is_object($this->supplierId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('supplierId', TType::STRUCT, 2);
      $xfer += $this->supplierId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderGoods_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderGoodsInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderGoods_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size92 = 0;
            $_etype95 = 0;
            $xfer += $input->readListBegin($_etype95, $_size92);
            for ($_i96 = 0; $_i96 < $_size92; ++$_i96)
            {
              $elem97 = null;
              $elem97 = new \ORDER\OrderGoodsInfoDTO();
              $xfer += $elem97->read($input);
              $this->success []= $elem97;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderGoods_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter98)
          {
            $xfer += $iter98->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderShippingInfo_args {
  static $_TSPEC;

  public $orderSn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderShippingInfo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderShippingInfo_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderShippingInfo_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderShippingInfoDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderShippingInfo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\OrderShippingInfoDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderShippingInfo_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderPreferentialInfo_args {
  static $_TSPEC;

  public $orderSn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderPreferentialInfo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderPreferentialInfo_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderPreferentialInfo_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderPreferentialInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderPreferentialInfo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size99 = 0;
            $_etype102 = 0;
            $xfer += $input->readListBegin($_etype102, $_size99);
            for ($_i103 = 0; $_i103 < $_size99; ++$_i103)
            {
              $elem104 = null;
              $elem104 = new \ORDER\OrderPreferentialInfoDTO();
              $xfer += $elem104->read($input);
              $this->success []= $elem104;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderPreferentialInfo_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter105)
          {
            $xfer += $iter105->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_initGoodsStock_args {
  static $_TSPEC;

  public $goodsStockList = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'goodsStockList',
          'type' => TType::LST,
          'etype' => TType::MAP,
          'elem' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::STRING,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['goodsStockList'])) {
        $this->goodsStockList = $vals['goodsStockList'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_initGoodsStock_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->goodsStockList = array();
            $_size106 = 0;
            $_etype109 = 0;
            $xfer += $input->readListBegin($_etype109, $_size106);
            for ($_i110 = 0; $_i110 < $_size106; ++$_i110)
            {
              $elem111 = null;
              $elem111 = array();
              $_size112 = 0;
              $_ktype113 = 0;
              $_vtype114 = 0;
              $xfer += $input->readMapBegin($_ktype113, $_vtype114, $_size112);
              for ($_i116 = 0; $_i116 < $_size112; ++$_i116)
              {
                $key117 = '';
                $val118 = '';
                $xfer += $input->readString($key117);
                $xfer += $input->readString($val118);
                $elem111[$key117] = $val118;
              }
              $xfer += $input->readMapEnd();
              $this->goodsStockList []= $elem111;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_initGoodsStock_args');
    if ($this->goodsStockList !== null) {
      if (!is_array($this->goodsStockList)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('goodsStockList', TType::LST, 1);
      {
        $output->writeListBegin(TType::MAP, count($this->goodsStockList));
        {
          foreach ($this->goodsStockList as $iter119)
          {
            {
              $output->writeMapBegin(TType::STRING, TType::STRING, count($iter119));
              {
                foreach ($iter119 as $kiter120 => $viter121)
                {
                  $xfer += $output->writeString($kiter120);
                  $xfer += $output->writeString($viter121);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_initGoodsStock_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_initGoodsStock_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_initGoodsStock_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_updateGoodsStock_args {
  static $_TSPEC;

  public $goodsId = null;
  public $orderType = null;
  public $updateSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'goodsId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        3 => array(
          'var' => 'updateSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['goodsId'])) {
        $this->goodsId = $vals['goodsId'];
      }
      if (isset($vals['orderType'])) {
        $this->orderType = $vals['orderType'];
      }
      if (isset($vals['updateSize'])) {
        $this->updateSize = $vals['updateSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_updateGoodsStock_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->goodsId = new \ORDER\StringDTO();
            $xfer += $this->goodsId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderType = new \ORDER\StringDTO();
            $xfer += $this->orderType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->updateSize = new \ORDER\StringDTO();
            $xfer += $this->updateSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_updateGoodsStock_args');
    if ($this->goodsId !== null) {
      if (!is_object($this->goodsId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('goodsId', TType::STRUCT, 1);
      $xfer += $this->goodsId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderType !== null) {
      if (!is_object($this->orderType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderType', TType::STRUCT, 2);
      $xfer += $this->orderType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->updateSize !== null) {
      if (!is_object($this->updateSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('updateSize', TType::STRUCT, 3);
      $xfer += $this->updateSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_updateGoodsStock_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_updateGoodsStock_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_updateGoodsStock_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_addGoodsStock_args {
  static $_TSPEC;

  public $goodsId = null;
  public $orderType = null;
  public $updateSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'goodsId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        3 => array(
          'var' => 'updateSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['goodsId'])) {
        $this->goodsId = $vals['goodsId'];
      }
      if (isset($vals['orderType'])) {
        $this->orderType = $vals['orderType'];
      }
      if (isset($vals['updateSize'])) {
        $this->updateSize = $vals['updateSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_addGoodsStock_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->goodsId = new \ORDER\StringDTO();
            $xfer += $this->goodsId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderType = new \ORDER\StringDTO();
            $xfer += $this->orderType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->updateSize = new \ORDER\StringDTO();
            $xfer += $this->updateSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_addGoodsStock_args');
    if ($this->goodsId !== null) {
      if (!is_object($this->goodsId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('goodsId', TType::STRUCT, 1);
      $xfer += $this->goodsId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderType !== null) {
      if (!is_object($this->orderType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderType', TType::STRUCT, 2);
      $xfer += $this->orderType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->updateSize !== null) {
      if (!is_object($this->updateSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('updateSize', TType::STRUCT, 3);
      $xfer += $this->updateSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_addGoodsStock_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_addGoodsStock_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_addGoodsStock_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_queryGoodsStock_args {
  static $_TSPEC;

  public $goodsId = null;
  public $orderType = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'goodsId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'orderType',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['goodsId'])) {
        $this->goodsId = $vals['goodsId'];
      }
      if (isset($vals['orderType'])) {
        $this->orderType = $vals['orderType'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_queryGoodsStock_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->goodsId = new \ORDER\StringDTO();
            $xfer += $this->goodsId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->orderType = new \ORDER\StringDTO();
            $xfer += $this->orderType->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_queryGoodsStock_args');
    if ($this->goodsId !== null) {
      if (!is_object($this->goodsId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('goodsId', TType::STRUCT, 1);
      $xfer += $this->goodsId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderType !== null) {
      if (!is_object($this->orderType)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderType', TType::STRUCT, 2);
      $xfer += $this->orderType->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_queryGoodsStock_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_queryGoodsStock_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\IntDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_queryGoodsStock_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_updateU8Status_args {
  static $_TSPEC;

  public $orderSn = null;
  public $status = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'status',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_updateU8Status_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->status = new \ORDER\IntDTO();
            $xfer += $this->status->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_updateU8Status_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      if (!is_object($this->status)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('status', TType::STRUCT, 2);
      $xfer += $this->status->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_updateU8Status_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_updateU8Status_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_updateU8Status_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getAllOrdersByCondition_args {
  static $_TSPEC;

  public $conditions = null;
  public $currentPage = null;
  public $pageSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'currentPage',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        3 => array(
          'var' => 'pageSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
      if (isset($vals['currentPage'])) {
        $this->currentPage = $vals['currentPage'];
      }
      if (isset($vals['pageSize'])) {
        $this->pageSize = $vals['pageSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getAllOrdersByCondition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size122 = 0;
            $_ktype123 = 0;
            $_vtype124 = 0;
            $xfer += $input->readMapBegin($_ktype123, $_vtype124, $_size122);
            for ($_i126 = 0; $_i126 < $_size122; ++$_i126)
            {
              $key127 = '';
              $val128 = '';
              $xfer += $input->readString($key127);
              $xfer += $input->readString($val128);
              $this->conditions[$key127] = $val128;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->currentPage = new \ORDER\IntDTO();
            $xfer += $this->currentPage->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->pageSize = new \ORDER\IntDTO();
            $xfer += $this->pageSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getAllOrdersByCondition_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter129 => $viter130)
          {
            $xfer += $output->writeString($kiter129);
            $xfer += $output->writeString($viter130);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentPage !== null) {
      if (!is_object($this->currentPage)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('currentPage', TType::STRUCT, 2);
      $xfer += $this->currentPage->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pageSize !== null) {
      if (!is_object($this->pageSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pageSize', TType::STRUCT, 3);
      $xfer += $this->pageSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getAllOrdersByCondition_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getAllOrdersByCondition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size131 = 0;
            $_etype134 = 0;
            $xfer += $input->readListBegin($_etype134, $_size131);
            for ($_i135 = 0; $_i135 < $_size131; ++$_i135)
            {
              $elem136 = null;
              $elem136 = new \ORDER\OrderInfoDTO();
              $xfer += $elem136->read($input);
              $this->success []= $elem136;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getAllOrdersByCondition_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter137)
          {
            $xfer += $iter137->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getAllOrdersCountByCondition_args {
  static $_TSPEC;

  public $conditions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getAllOrdersCountByCondition_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size138 = 0;
            $_ktype139 = 0;
            $_vtype140 = 0;
            $xfer += $input->readMapBegin($_ktype139, $_vtype140, $_size138);
            for ($_i142 = 0; $_i142 < $_size138; ++$_i142)
            {
              $key143 = '';
              $val144 = '';
              $xfer += $input->readString($key143);
              $xfer += $input->readString($val144);
              $this->conditions[$key143] = $val144;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getAllOrdersCountByCondition_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter145 => $viter146)
          {
            $xfer += $output->writeString($kiter145);
            $xfer += $output->writeString($viter146);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getAllOrdersCountByCondition_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getAllOrdersCountByCondition_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\IntDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getAllOrdersCountByCondition_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersByOrderPsn_args {
  static $_TSPEC;

  public $orderSn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersByOrderPsn_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersByOrderPsn_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersByOrderPsn_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderSubDetailInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersByOrderPsn_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size147 = 0;
            $_etype150 = 0;
            $xfer += $input->readListBegin($_etype150, $_size147);
            for ($_i151 = 0; $_i151 < $_size147; ++$_i151)
            {
              $elem152 = null;
              $elem152 = new \ORDER\OrderSubDetailInfoDTO();
              $xfer += $elem152->read($input);
              $this->success []= $elem152;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersByOrderPsn_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter153)
          {
            $xfer += $iter153->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderLogInfoBySn_args {
  static $_TSPEC;

  public $orderSn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderLogInfoBySn_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderLogInfoBySn_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrderLogInfoBySn_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderLogInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrderLogInfoBySn_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size154 = 0;
            $_etype157 = 0;
            $xfer += $input->readListBegin($_etype157, $_size154);
            for ($_i158 = 0; $_i158 < $_size154; ++$_i158)
            {
              $elem159 = null;
              $elem159 = new \ORDER\OrderLogInfoDTO();
              $xfer += $elem159->read($input);
              $this->success []= $elem159;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrderLogInfoBySn_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter160)
          {
            $xfer += $iter160->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersByOperate_args {
  static $_TSPEC;

  public $conditions = null;
  public $currentPage = null;
  public $pageSize = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'currentPage',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        3 => array(
          'var' => 'pageSize',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
      if (isset($vals['currentPage'])) {
        $this->currentPage = $vals['currentPage'];
      }
      if (isset($vals['pageSize'])) {
        $this->pageSize = $vals['pageSize'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersByOperate_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size161 = 0;
            $_ktype162 = 0;
            $_vtype163 = 0;
            $xfer += $input->readMapBegin($_ktype162, $_vtype163, $_size161);
            for ($_i165 = 0; $_i165 < $_size161; ++$_i165)
            {
              $key166 = '';
              $val167 = '';
              $xfer += $input->readString($key166);
              $xfer += $input->readString($val167);
              $this->conditions[$key166] = $val167;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->currentPage = new \ORDER\IntDTO();
            $xfer += $this->currentPage->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->pageSize = new \ORDER\IntDTO();
            $xfer += $this->pageSize->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersByOperate_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter168 => $viter169)
          {
            $xfer += $output->writeString($kiter168);
            $xfer += $output->writeString($viter169);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentPage !== null) {
      if (!is_object($this->currentPage)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('currentPage', TType::STRUCT, 2);
      $xfer += $this->currentPage->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->pageSize !== null) {
      if (!is_object($this->pageSize)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('pageSize', TType::STRUCT, 3);
      $xfer += $this->pageSize->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersByOperate_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ORDER\OrderSubDetailInfoDTO',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersByOperate_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size170 = 0;
            $_etype173 = 0;
            $xfer += $input->readListBegin($_etype173, $_size170);
            for ($_i174 = 0; $_i174 < $_size170; ++$_i174)
            {
              $elem175 = null;
              $elem175 = new \ORDER\OrderSubDetailInfoDTO();
              $xfer += $elem175->read($input);
              $this->success []= $elem175;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersByOperate_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter176)
          {
            $xfer += $iter176->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersCountByOperate_args {
  static $_TSPEC;

  public $conditions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'conditions',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['conditions'])) {
        $this->conditions = $vals['conditions'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersCountByOperate_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->conditions = array();
            $_size177 = 0;
            $_ktype178 = 0;
            $_vtype179 = 0;
            $xfer += $input->readMapBegin($_ktype178, $_vtype179, $_size177);
            for ($_i181 = 0; $_i181 < $_size177; ++$_i181)
            {
              $key182 = '';
              $val183 = '';
              $xfer += $input->readString($key182);
              $xfer += $input->readString($val183);
              $this->conditions[$key182] = $val183;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersCountByOperate_args');
    if ($this->conditions !== null) {
      if (!is_array($this->conditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('conditions', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->conditions));
        {
          foreach ($this->conditions as $kiter184 => $viter185)
          {
            $xfer += $output->writeString($kiter184);
            $xfer += $output->writeString($viter185);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_getOrdersCountByOperate_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\IntDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_getOrdersCountByOperate_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\IntDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_getOrdersCountByOperate_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_updatePayInfo_args {
  static $_TSPEC;

  public $orderSn = null;
  public $payId = null;
  public $payWay = null;
  public $payUrl = null;
  public $orderOperatorDTO = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'orderSn',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        2 => array(
          'var' => 'payId',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        3 => array(
          'var' => 'payWay',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        4 => array(
          'var' => 'payUrl',
          'type' => TType::STRUCT,
          'class' => '\ORDER\StringDTO',
          ),
        5 => array(
          'var' => 'orderOperatorDTO',
          'type' => TType::STRUCT,
          'class' => '\ORDER\OrderOperatorDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['orderSn'])) {
        $this->orderSn = $vals['orderSn'];
      }
      if (isset($vals['payId'])) {
        $this->payId = $vals['payId'];
      }
      if (isset($vals['payWay'])) {
        $this->payWay = $vals['payWay'];
      }
      if (isset($vals['payUrl'])) {
        $this->payUrl = $vals['payUrl'];
      }
      if (isset($vals['orderOperatorDTO'])) {
        $this->orderOperatorDTO = $vals['orderOperatorDTO'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_updatePayInfo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->orderSn = new \ORDER\StringDTO();
            $xfer += $this->orderSn->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->payId = new \ORDER\StringDTO();
            $xfer += $this->payId->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->payWay = new \ORDER\StringDTO();
            $xfer += $this->payWay->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->payUrl = new \ORDER\StringDTO();
            $xfer += $this->payUrl->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->orderOperatorDTO = new \ORDER\OrderOperatorDTO();
            $xfer += $this->orderOperatorDTO->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_updatePayInfo_args');
    if ($this->orderSn !== null) {
      if (!is_object($this->orderSn)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderSn', TType::STRUCT, 1);
      $xfer += $this->orderSn->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->payId !== null) {
      if (!is_object($this->payId)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('payId', TType::STRUCT, 2);
      $xfer += $this->payId->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->payWay !== null) {
      if (!is_object($this->payWay)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('payWay', TType::STRUCT, 3);
      $xfer += $this->payWay->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->payUrl !== null) {
      if (!is_object($this->payUrl)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('payUrl', TType::STRUCT, 4);
      $xfer += $this->payUrl->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orderOperatorDTO !== null) {
      if (!is_object($this->orderOperatorDTO)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('orderOperatorDTO', TType::STRUCT, 5);
      $xfer += $this->orderOperatorDTO->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OrderInfoService_updatePayInfo_result {
  static $_TSPEC;

  public $success = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => '\ORDER\BooleanDTO',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
    }
  }

  public function getName() {
    return 'OrderInfoService_updatePayInfo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new \ORDER\BooleanDTO();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OrderInfoService_updatePayInfo_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


